---
layout: post
title:  "Milestone 1"
date:   11-11-2016 12:00:00
author: pomodorest
categories: proyect
---

## Introducción 
Ya avanzado el curso CC5407 del departamento de Ciencias de la Computación de la Facultad de Ingeniería de la Universidad de Chile y realizada la lluvia de ideas sobre los problemas de ROS, se seleccionó abordar los problemas de tele_op para mejorar su implementación.

Existen diversos programas de operaciones a distancia sobre robots. Estos se encargan de permitir al usuario controlar sus robots via mensajes anclados a teclas de un teclado o a botones/palancas de joysticks. Las opciones open-source disponibles presentan diversas limitaciones a su usabilidad. En este informe se explicará cuales son estas debilidades, la solución planteada para esta problemática, el avance desarrollado hasta la fecha en dicha solución y la forma en que se pretende integrar esta solución a ROS para hacerla distendida y usada como buena solución.


## Problema

Los tele-ops actuales sufren de ser poco usables en distintos ambitos. Se categorizan de la siguiente manera:

* Arbitrarios

Las teclas por defecto en los programas de teleoperaciones abiertos son arbitrarias. Existen diversas opciones estandarizadas de distribución de controles en un teclado, pero por algún motivo estos programas deciden no utilizar ninguna de estas y solo disponerlas como al creador le pareció. Esto produce que el usuario tenga que acostumbrarse a un nuevo set de controles que no necesariamente es cómodo a la mano humana.

* Poco configurable

Por si fuera poco, no es posible alterar que teclas se usarán en estos programas. Existe un proyecto deprecado en que esto era posible, pero las opciones actuales no disponen de configuraciones más allá de alterar la velocidad de movimiento. Además, no es posible enviar mensajes que no se encuentren dentro de los disponibles en el programa, y por tanto el control que se tiene sobre el robot es limitado a lo que el programa permita.

[Imagen de los controles feos]

* Inconsistente

Al intentar subir ó bajar la velocidad en el tele-op por defecto, esta velocidad se ve incrementada o reducida por un 10% del valor actual. Esto produce que sin importar que subidas o bajadas de velocidad se hagan, cada una va a incrementar el número de dígitos necesarios para representar la velocidad.

[Imagen de las velocidades wonky]

* Autista

La misma falta de configuración no permite que se pueda publicar mensajes a nuevos tópicos, permitiendo utilizar el sistema para diversos robots, y finalmente se tiene un programa de teleoperación para un robot en específico. Además, no es posible enviar tipos de mensajes distinto a los Twists que maneja tele-op, reduciendo aún más su compatibilidad. 

* Egoista

Para rematar, los tele-op actuales envían mensajes constantemente, de modo que es imposible utilizar más de un programa de tele-op sobre un mismo robot. Cuando un usuario deja un tele-op de control sobre un robot y desea enviarle un mensaje desde otra fuente, tele-op va a hacer que dicho mensaje no tenga efecto oportuno antes de recibir otro mensaje de velocidad cero, manteniendo al robot estático. 

## Solución 

Para resolver estos problemas, se plantea programar tele-dir.

En vista de los problemas planteados, se busca hacer un programa de tele-dir un programa de teleoperaciones más amigable. En un principio, la clara debilidad de los tele-op es su falta de configuración, siendo la raíz de casi todos sus defectos. 

Por esto, luego de investigar diversas opciones de sistemas de configuración, se optó por utilizar un archivo XML para guardar la información de configuración. La decisión se basó en su compatibilidad con librerías disponibles en python que es de las opciones que permite ROS, y en la previa experiencia de uso en otros proyectos. 

### XML

Se comenzó por diseñar un archivo de configuración en XML por defecto que permitiera relacionar algún mensaje, con algún tópico y disponerlo sobre alguna tecla. Este modelo se iteraría a través del desarrollo del sistema a medida que se avanzara en el proyecto. 

Paralelamente en Python se desarrolló un programa capaz de leer dicho archivo de configuración y llevar a cabo el envío de mensajes a sus tópicos correspondientes al presionar el botón asignado. Se dió enfasis en que no se enviara mensajes cuando ninguna tecla estuviera presionada. 

Hecho esto, se pudo iterar más profundamente en el XML y se llegó a la siguiente disposición:

[Imagen del XML con todas las pestañas (+) cerradas (-)]
[Imagen del XML con 1 ejemplo de boton, mensaje y tópico para dar de ejemplo]

Se dividió el archivo en dos partes. Una descripción y una configuración.

La descripción permite soportar los distintos datos necesarios para distinguir un archivo de configuración de otro. Permite que el usuario entregue un nombre a la configuración, un nombre para el robot al que está dirigido, y un número de versión que aumenta en cada iteración que se haga sobre dicha configuración. 

La configuración cuenta de tres listados: un listado de tópicos, uno de mensajes y uno de botones.

El listado de tópicos guarda la dirección de cada tópico al que se desea enviar mensajes, el tipo de mensaje que recibe (con propositos de validación) y un identificador.

El listado de mensajes guarda el tipo del mensaje, su contenido, una descripción que especifique el propòsito del mensaje, y un identificador.

El listado de botones guarda la tecla con que se desea enviar un mensaje, el identificador de dicho mensaje, y el identificador del tópico al que se enviará dicho mensaje.

### Python

Una vez definido el archivo de configuración, se da paso a las distintas operaciones que se requieren sobre dicho archivo. 

En python, como se dijo en la sección de XML, se programó un sistema que se encarga de que al presionar un botón especificado en el XML, se envíe el mensaje especificado al tópico especificado. ¿Que pasa si el mensaje tuviera un tipo que no soporta el tópico en cuestión?

Para evitar caer en errores de ROS por la configuración defectuosa, se programó un validador de configuración. Este programa lee el archivo de configuración y detecta que existan mensajes, tópicos y botones, y de que cada mensaje que se envía a cada tópico sea de un tipo válido para ROS y que sea de un tipo soportado por el tópico al que se envía. 

## Problemas de la solución

## Diseño de la solución

## Integración

## Conclusión 
-
